# -*- coding: utf-8 -*-
"""Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pIr-FRAmB7YH3TKPg0duib7f-r2x9n3k
"""

from google.colab import files
uploaded = files.upload()

import csv
import math

def parse_coordinates(file_path):
    coordinates = {}
    with open(file_path, mode='r') as infile:
        reader = csv.reader(infile)
        next(reader)  # Skip header
        for rows in reader:
            star, x, y, z = rows[0], float(rows[1]), float(rows[2]), float(rows[3])
            coordinates[star] = (x, y, z)
    return coordinates

def parse_distances(file_path):
    distances = {}
    with open(file_path, mode='r') as infile:
        reader = csv.reader(infile)
        next(reader)  # Skip header
        for rows in reader:
            star1, star2, distance = rows[0], rows[1], float(rows[2])
            if star1 not in distances:
                distances[star1] = []
            if star2 not in distances:
                distances[star2] = []
            distances[star1].append((star2, distance))
            distances[star2].append((star1, distance))
    return distances

# File paths
coordinates_file_path = 'Coordinates.csv'
distances_file_path = 'distances.csv'

coordinates = parse_coordinates(coordinates_file_path)
distances = parse_distances(distances_file_path)

from math import sqrt

def euclidean_distance(coord1, coord2):
    return sqrt(sum((x - y) ** 2 for x, y in zip(coord1, coord2)))

def manhattan_distance(coord1, coord2):
    return sum(abs(x - y) for x, y in zip(coord1, coord2))

import heapq

def dijkstra(graph, start, goal):
    queue = [(0, start)]
    distances = {start: 0}
    previous_nodes = {start: None}

    while queue:
        current_distance, current_node = heapq.heappop(queue)

        if current_node == goal:
            path = []
            while previous_nodes[current_node] is not None:
                path.append(current_node)
                current_node = previous_nodes[current_node]
            path.append(start)
            return path[::-1], current_distance

        for neighbor, weight in graph.get(current_node, []):
            distance = current_distance + weight
            if neighbor not in distances or distance < distances[neighbor]:
                distances[neighbor] = distance
                previous_nodes[neighbor] = current_node
                heapq.heappush(queue, (distance, neighbor))

    return None, float('inf')

def a_star(graph, start, goal, h_func):
    open_set = [(0, start)]
    g_costs = {start: 0}
    f_costs = {start: h_func(start, goal)}
    previous_nodes = {start: None}

    while open_set:
        current_f_cost, current_node = heapq.heappop(open_set)

        if current_node == goal:
            path = []
            while previous_nodes[current_node] is not None:
                path.append(current_node)
                current_node = previous_nodes[current_node]
            path.append(start)
            return path[::-1], g_costs[goal]

        for neighbor, weight in graph.get(current_node, []):
            tentative_g_cost = g_costs[current_node] + weight
            if neighbor not in g_costs or tentative_g_cost < g_costs[neighbor]:
                previous_nodes[neighbor] = current_node
                g_costs[neighbor] = tentative_g_cost
                f_costs[neighbor] = tentative_g_cost + h_func(neighbor, goal)
                heapq.heappush(open_set, (f_costs[neighbor], neighbor))

    return None, float('inf')

import time

# Dijkstra
start_time = time.time()
path, distance = dijkstra(distances, 'Sun', 'Upsilon Andromedae')
end_time = time.time()
print(f"Dijkstra: Path: {path}, Cost: {distance}, Time: {(end_time - start_time) * 1000:.2f} ms")

# A*
start_time = time.time()
path, distance = a_star(distances, 'Sun', 'Upsilon Andromedae', lambda s, g: euclidean_distance(coordinates[s], coordinates[g]))
end_time = time.time()
print(f"A*: Path: {path}, Cost: {distance}, Time: {(end_time - start_time) * 1000:.2f} ms")

